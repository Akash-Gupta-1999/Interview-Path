Application Layer, Microservices & Service Discovery (System Design Overview)

-   Separating Web Layer and Application Layer

    Modern scalable architectures separate the web layer (handling HTTP requests, routing, SSL termination, load balancing) from the application/platform layer (business logic, APIs, workers).

    Why this separation?

    - Independent Scalability  
    Each layer can scale on its own.  
    Example: Adding new APIs → add more *application servers* without increasing web servers.

    - Single Responsibility Principle (SRP)  
    Encourages small, autonomous services focused on a specific responsibility.

    - Smaller Teams, Faster Growth  
    Each team owns a small service → easier planning, deployment, and scaling.

    - Enables Async Processing  
    Application layer workers (job servers) can be used for background processing, queues, and asynchronous tasks.

-   Microservices

        Microservices represent an architectural style where a system is built as a suite of small, independently deployable services.

        Characteristics:

        - Each service:
            - Has a single business capability
            - Runs its own process
            - Communicates with other services via lightweight mechanisms (HTTP/REST, gRPC, queues)

        - Designed for autonomy, independent deployment, and fault isolation.

        Example (Pinterest):

        Possible microservices:
        - User profile service
        - Followers service
        - Feed generation service
        - Search service
        - Photo upload service

        Each service can scale independently depending on load.

-   Service Discovery

    In microservices architecture, services must find and communicate with each other dynamically.

    Service discovery systems store:
    - Service names
    - IP addresses
    - Ports
    - Health information

    Common Tools:
    - Consul
    - Etcd
    - Zookeeper

    How they work:
    - Services register themselves with the registry.
    - Other services query the registry to find where the service is running.
    - Health checks (usually HTTP endpoints like `/health`) ensure only healthy instances receive traffic.
    - Consul and Etcd also provide a key-value store for configs and shared metadata.

-   Disadvantages (Application Layer & Microservices)

    While powerful, this architecture has downsides:

    Complexity
    - Requires a different mindset compared to monolithic apps.
    - More moving parts:
        - service discovery
        - orchestration
        - logging
        - monitoring
        - distributed tracing
    - Deployments become more complex (CI/CD required).

    Operational Overhead
    - More services → more configurations, pipelines, and resources.
    - Need sophisticated DevOps tooling and infrastructure.