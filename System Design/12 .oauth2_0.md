-    Authentication vs Authorization
    -   Authentication â€” Who are you?
        - Verifies identity  
        - Confirms the user is who they claim to be  

        Examples:
        - Login with username & password  
        - OTP verification  
        - Fingerprint / Face ID  
        - OpenID Connect (OIDC)  

        ðŸ“Œ Happens first
    -   Authorization â€” What are you allowed to do?
        - Determines permissions  
        - Controls access to resources after authentication  

        Examples:
        - User can read data but not delete  
        - Admin can access `/admin` endpoint  
        - User can view own profile but not othersâ€™  

        ðŸ“Œ Happens after authentication
    -   Real-Life Analogy
        - Authentication: Showing your ID at the office entrance  
        - Authorization: Access card decides which rooms you can enter  

        ðŸ‘‰ You might be authenticated (valid employee)  
        but not authorized (canâ€™t enter CEO cabin)

-   OAuth 2.0 & OpenID Connect 
    -   History & Motivation (Explained, Not Just Listed)

        In the early days of the web, when one application wanted access to data stored in another service, there was only one practical option:
        - The user shared their username and password with the thirdâ€‘party app  
        - That app logged in as the user and accessed everything  

        Concrete example:  
        An app wants to read your email contacts â†’ you give it your email password.  

        This was convenient but fundamentally broken from a security standpoint.

        -   Why This Model Was Dangerous
            - Thirdâ€‘party apps could store passwords insecurely  
            - Apps received full account access, not limited access  
            - Users had no visibility into what the app was doing  
            - Revoking access meant changing your password everywhere  

        -   The industry needed a way to:
            - Avoid password sharing  
            - Limit what apps could do  
            - Allow revocation without breaking the userâ€™s account  

        -   The Core Idea Introduced
            Instead of giving an app your credentials, give it a temporary, limited key:

            - The key only allows specific actions  
            - The key can expire automatically  
            - The key can be revoked independently  

            This idea is called delegated authorization.  
            OAuth 2.0 is the standardization of this idea.

    -   OAuth 2.0
        OAuth 2.0 defines a way for: One application to access another applicationâ€™s resources on behalf of a user, without learning the userâ€™s password.

        Important emphasis:
        - OAuth does not define identity  
        - OAuth does not define login  
        - OAuth only defines permission delegation  

        ðŸ“Œ OAuth answers: â€œIs this app allowed to access this resource, and how?â€

    -   Why OpenID Connect Was Needed
        As OAuth adoption grew, developers started using it for login flows (e.g., â€œSign in with Googleâ€).  

        But OAuth never standardized:
        - How to identify the user  
        - How to safely transmit identity information  

        To solve this cleanly, OpenID Connect (OIDC) was introduced.

        OIDC:
        - Is built on top of OAuth 2.0  
        - Adds a standard identity token  
        - Clearly separates authentication from authorization  

    -   OAuth & OIDC

        -   OAuth 2.0
            OAuth 2.0 is a delegated authorization framework.  
            It allows an application to:
            - Obtain limited access to a userâ€™s resources  
            - Without ever seeing the userâ€™s credentials  

            OAuth answers:  
            > â€œWhat access does this application have?â€

        -   OpenID Connect (OIDC)
            OpenID Connect is an authentication layer built on OAuth 2.0.  
            It provides:
            - A verified user identity  
            - Standard identity claims  
            - Single Signâ€‘On (SSO)  

            OIDC answers:  
            > â€œWho is the user?â€

        -   OAuth Actors (Explained With Context)
            - Resource Owner: The user who owns the data  
            - Client: The application requesting access  
            - Authorization Server: The system that authenticates the user and issues tokens  
            - Resource Server: The API that stores the protected data  

            These roles may be implemented by the same system (e.g., Google), but logically they are separate.

    -   Front Channel vs Back Channel

        -   Front Channel Communication
            Front channel communication happens through the userâ€™s browser.

            Examples:
            - Redirecting the user to the authorization server  
            - Redirecting the user back to the client with an authorization code  

            Characteristics:
            - Visible to the browser  
            - Vulnerable to interception if misused  
            - Used only for temporary data (like authorization codes)  

            ðŸ“Œ Never send tokens or secrets via the front channel.

        -   Back Channel Communication
            Back channel communication happens serverâ€‘toâ€‘server, without the userâ€™s browser.

            Examples:
            - Client exchanging authorization code for tokens  
            - Token refresh requests  

            Characteristics:
            - Secure (TLSâ€‘protected)    
            - Client can authenticate itself  
            - Used for sensitive data (tokens, secrets)  

            ðŸ“Œ OAuth is designed so that sensitive credentials only flow through the back channel.

    -   Client ID vs Client Secret

        Client ID
        - Public identifier of the application  
        - Safe to expose in browser redirects  
        - Used to identify which app is making the request  

        Client Secret
        - Confidential credential shared between client and authorization server  
        - Proves the identity of the client application  
        - Used only in back channel communication  

        ðŸ“Œ The client secret is NOT used to authenticate the user.

    -   How Client Secret Is Used to Get an Access Token
        During the token request (back channel):
        - Client sends:  
            - Authorization code  
            - Client ID  
            - Client Secret  

        The authorization server:
            - Verifies the code  
            - Verifies the client secret  
            - Ensures the request comes from the legitimate app  

        Only then does it issue an access token.

    -   Tokens Explained Properly

        Access Token
        - Represents authorization, not identity  
        - Used to call APIs  
        - Shortâ€‘lived  
        - Audience: Resource Server  
        - Format: JWT or opaque  

        Refresh Token (different then authorization code as it requires user to login first)
        - Used to obtain new access tokens  
        - Longâ€‘lived  
        - Never sent through front channel  
        - Stored securely  

        ID Token (OIDC)
        - Proves authentication  
        - Always a JWT  
        - Audience: Client  
        - Contains identity claims (`sub`, `email`, etc.) 
    
    -   PKCE (Proof Key for Code Exchange)

        -   Why PKCE Exists
            In public clients (SPAs, mobile apps): (SPA - Single Page Application)
            - You cannot safely store a client secret  
            - Authorization codes travel through the front channel  

            This makes authorization code interception attacks possible.
        
        -   code_verifier (The Secret)
            What is it?
            -   A random, high-entropy string
            -   Generated per authorization request
            -   Kept only by the client
            -   Example
                code_verifier = 
                "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"

            -   Properties
                -   Length: 43â€“128 characters
                -   URL-safe
                -   Never sent in front channel

            This is the â€œproofâ€ in Proof Key for Code Exchange.
        
        -   code_challenge (The Commitment)
            What is it?
            -   A one-way transformation of the code_verifier.
            -   Most commonly:
                -   code_challenge = BASE64URL(SHA256(code_verifier))
                -   Example
                    code_challenge =
                    "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"

            -   Why hashing?
                -   Authorization Server never sees the verifier
                -   Prevents interception attacks
                -   Allows later verification

        -   Step-by-Step PKCE Flow (Mapped to OAuth)
            1.  Client Generates Verifier & Challenge
                code_verifier  â†’  random secret
                code_challenge â†’  hash(verifier)

                Client stores code_verifier in memory.

            2.  Client Sends Authorization Request (Front Channel)
                https://auth.server.com/authorize?
                response_type=code
                &client_id=spa_app
                &redirect_uri=https://app.com/callback
                &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
                &code_challenge_method=S256  ----------> hash method

                -   Authorization Server:
                    -   Stores the code_challenge
                    -   Associates it with the authorization code

            3.  Authorization Code Issued
                https://app.com/callback?code=abc123

                Attacker may steal this code.

            4.  Token Exchange (Back Channel)

                -   Client sends:
                    -   POST /token

                        grant_type=authorization_code
                        &code=abc123
                        &code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

            5.  Authorization Server Verifies

                -   Server:
                    -   Takes stored code_challenge
                    -   Hashes received code_verifier
                    -   Compares results: SHA256(code_verifier) == code_challenge ?
                        âœ… Match â†’ issue tokens
                        âŒ No match â†’ reject

            -   Why This Stops Authorization Code Theft
                Attack scenario: Attacker steals: code = abc123. But attacker does not have: code_verifier
                âŒ Cannot generate correct verifier
                âŒ Token endpoint rejects request

                ðŸ“Œ Authorization code becomes useless without verifier.  

    -   Authorization Code Flow â€” Deep, End-to-End Explanation

        Weâ€™ll use this concrete example throughout:

        - Client (App): photos-app.com  
        - Authorization Server: auth.google.com  
        - Resource Server: api.google.com  
        - User: Alice  

        -   Client Registration (Happens BEFORE Any OAuth Flow)

            Before OAuth ever runs, the client registers with the Authorization Server.

            -   What happens during registration?
                -   Client gets: client_id, client_secret
                -   Authorization Server stores: client_id â†’ client_secret mapping, allowed redirect URIs, allowed grant types

            This is NOT part of the runtime OAuth flow. Think of it like creating a service account.

        1.  Client â†’ Authorization Server (Front Channel)

            What is happening?
            The client redirects the userâ€™s browser to the Authorization Server to:
            - Authenticate the user  
            - Ask for consent  

            This happens via the front channel (browser redirect).

            -   Who is talking to whom?
                Browser (on behalf of Client) â†’ Authorization Server

            -   Example Redirect URL
                https://auth.google.com/oauth2/v2/auth?
                response_type=code
                &client_id=photo_app_123
                &redirect_uri=https://photos-app.com/callback
                &scope=openid profile email
                &state=xyz123

            -   Important Parameters Explained
                | Parameter          | Meaning                                      |
                |--------------------|----------------------------------------------|
                | response_type=code | We want an authorization code                |
                | client_id          | Identifies the client app                    |
                | redirect_uri       | Where the auth server should send the user back |
                | scope              | What access the app is requesting            |
                | state              | CSRF protection                              |
                | openid             | Signals OpenID Connect (authentication)      |

            -   Why no client secret here?  
                Because this is the front channel â€” anything here is visible to the browser.

        2.  User Authenticates (At Authorization Server)

            What is happening?
            - User enters credentials directly on the Authorization Server  
            - Client never sees username/password  

            Who is talking to whom?
            -   User â†” Authorization Server

            Why this is important
            - Prevents password sharing  
            - Centralizes authentication  
            - Enables SSO  

            -   OAuth assumes authentication happens here, but does not define how.

        3.  User Grants Consent

            What is happening?
            -   The Authorization Server shows a consent screen:
                > â€œPhotos App wants to:  
                    > - View your profile  
                    > - View your emailâ€

            User clicks Allow or Deny.

            Who is talking to whom?
            -   User â†’ Authorization Server

            Why consent matters
            - Explicit user approval  
            - Scope-based permission  
            - Auditable access control  

        4.  Authorization Server â†’ Client (Front Channel)

            What is happening?
            The Authorization Server:
            - Generates a short-lived authorization code  
            - Redirects the browser back to the client  

            Still front channel.

            Who is talking to whom?
            -   Authorization Server â†’ Browser â†’ Client

            -   Example Redirect Back
                https://photos-app.com/callback?
                code=SplxlOBeZQQYbYS6WxSbIA
                &state=xyz123

            -   Parameters Explained
                | Parameter | Meaning                       |
                |-----------|-------------------------------|
                | code      | Temporary authorization code  |
                | state     | Must match original value     |

            -   Security properties of the code
                - Short-lived (seconds)  
                - Single-use  
                - Useless without client authentication (or PKCE)  

        5.  Client â†’ Authorization Server (Back Channel)

            What is happening?
                Now the client exchanges the authorization code for tokens.  
                ðŸ“Œ This is the back channel (server-to-server).

            Who is talking to whom?
            -   Client Server â†’ Authorization Server

            -   Example Token Request (HTTPS POST)
                POST https://auth.google.com/oauth2/token
                Content-Type: application/x-www-form-urlencoded
                grant_type=authorization_code
                &code=SplxlOBeZQQYbYS6WxSbIA
                &redirect_uri=https://photos-app.com/callback
                &client_id=photo_app_123
                &client_secret=super_secret_value

            -   Parameters Explained
                | Parameter     | Meaning                                |
                |---------------|----------------------------------------|
                | grant_type    | OAuth flow type                        |
                | code          | Authorization code from Step 4         |
                | redirect_uri  | Must match original                    |
                | client_id     | Identify client                        |
                | client_secret | Authenticate client                    |

            This is where the client secret is used

            -   Why this step is critical
            The Authorization Server verifies:
            - The authorization code is valid  
            - The client secret proves the caller is the real client  
            - The redirect URI matches  

            Only then are tokens issued.

        6.  Authorization Server â†’ Client (Back Channel)

            What is happening?
            -   The Authorization Server returns tokens.

            Who is talking to whom?
            -   Authorization Server â†’ Client Server

            -   Example Token Response (JWT : Javascript Web Token)
                json:
                {
                "access_token": "ya29.a0AfH6SMD...",
                "refresh_token": "1//0gL...",
                "id_token": "eyJhbGciOiJSUzI1NiIs...",
                "token_type": "Bearer",
                "expires_in": 3600
                }

        7.  Client â†’ Resource Server (API Access)

            (Often omitted but important for completeness)
            GET https://api.google.com/userinfo
            Authorization: Bearer ya29.a0AfH6SMD...

        -   How PKCE Fits Into This Flow (Short Recap)

            In public clients:
            - Step 5 does not use `client_secret`  
            - Instead uses:  
                - `code_verifier`  
                - `code_challenge`  

        This binds the authorization code to the original client.

+----------------+                        +-------------------+
|                |                        |                   |
|     Client     |                        | Authorization     |
|  (App / SPA /  |                        | Server (AuthZ)   |
|   Backend)     |                        |                   |
+----------------+                        +-------------------+
         |                                          |
         |  1. User clicks "Login / Connect"       |
         |---------------------------------------->|
         |                                          |
         |  2. Front Channel Redirect:             |
         |     - response_type=code               |
         |     - client_id                         |
         |     - redirect_uri                       |
         |     - scope (offline_access?)           |
         |     - code_challenge (PKCE)            |
         |     - code_challenge_method=S256        |
         |---------------------------------------->|
         |                                          |
         |  3. User Authenticates at AS            |
         |     - username/password / 2FA          |
         |     - consent screen (requested scopes)|
         |<----------------------------------------|
         |                                          |
         |  4. Front Channel Redirect Back         |
         |     - redirect_uri?code=AUTH_CODE      |
         |<----------------------------------------|
         |                                          |
         |  5. Back Channel Token Request          |
         |     POST /token                         |
         |     - grant_type=authorization_code     |
         |     - code=AUTH_CODE                     |
         |     - redirect_uri                        |
         |     - client_id / client_secret (confidential) |
         |     - code_verifier (PKCE public client)       |
         |---------------------------------------->|
         |                                          |
         |  6. Auth Server Validates:              |
         |     - Authorization code                |
         |     - code_verifier (PKCE)             |
         |     - client credentials                |
         |                                          |
         |  7. Auth Server Issues Tokens           |
         |     - access_token (short-lived)        |
         |     - refresh_token (long-lived, if scope=offline_access & client allowed) |
         |     - (OIDC) id_token (optional)        |
         |<----------------------------------------|
         |                                          |
         |  8. Client Uses Access Token to call    |
         |     Resource Server / APIs              |
         |     - Authorization: Bearer ACCESS_TOKEN|
         |---------------------------------------->|
         |                                          |
         |  9. Access Token Expires?               |
         |     - YES â†’ Use refresh token           |
         |                                          |
         | 10. Back Channel Token Refresh          |
         |     POST /token                         |
         |     - grant_type=refresh_token          |
         |     - refresh_token=REFRESH_TOKEN       |
         |     - client_id / client_secret (if confidential) |
         |---------------------------------------->|
         |                                          |
         | 11. Auth Server Issues New Access Token |
         |     - (Optional) rotates refresh token |
         |<----------------------------------------|

