-   What Is a Reverse Proxy?
    - A reverse proxy is a server that sits in front of backend servers and forwards client requests to them.  
    - From the clientâ€™s perspective, the reverse proxy is the web server â€” clients never directly connect to backend servers.  

    Flow: Client â†’ Reverse Proxy â†’ Backend Server â†’ Reverse Proxy â†’ Client
    - Client sends request to reverse proxy.  
    - Reverse proxy decides which backend server should handle it.  
    - Backend processes request.  
    - Reverse proxy returns response to client (appears as if proxy generated it).  

-   Why Is It Called Reverse Proxy?
    - Forward proxy: sits in front of clients (e.g., corporate proxies, VPNs).  
    - Reverse proxy: sits in front of servers.  
    - Clients donâ€™t know about backend servers â†’ proxy hides them (â€œreverseâ€ direction).  

-   Benefits of a Reverse Proxy

    A. Security (Major Reason)
    - Backend servers never exposed to internet (IPs remain private).  
    - Filters malicious traffic.  
    - Can block IPs (denylisting).  
    - Acts as early DDoS protection.  
    - Supports WAF (Web Application Firewall).  

    B. Scalability & Flexibility
    - Backend infra can change without affecting clients.  
    - Freely add/remove servers.  
    - Works seamlessly with load balancers.  

    C. Web Acceleration
    - Caching (static + dynamic content).  
    - SSL termination (offloading): proxy handles HTTPS, backend runs plain HTTP.  
    - Compression.  
    - Connection pooling.  

    D. Routing Logic
    - Routes requests based on:  
    - User device  
    - Geo location  
    - Time of day  
    - Server health  
    - A/B testing  

-   Reverse Proxy vs Load Balancer

    | Feature              | Reverse Proxy                        | Load Balancer                          |
    |----------------------|---------------------------------------|----------------------------------------|
    | Sits in front of?| Backend servers                      | Multiple backend servers                |
    | Purpose          | Security, routing, caching           | Distribute load                        |
    | Works with single server? | âœ” Yes                      | âœ˜ No                                   |
    | Hides backend servers? | âœ” Yes                        | âœ” Usually                              |
    | Caches responses?| âœ” Yes                                | âœ˜ No                                   |
    | SSL termination? | âœ” Yes                                | âœ” Yes                                  |
    | Key goal         | Abstraction + control                | Avoid overloaded servers               |

    ğŸ‘‰ In real systems, reverse proxies often include loadâ€‘balancing features.  
    Examples: Nginx, HAProxy, Envoy, Cloudflare.

-   Why Is a Reverse Proxy Important?
    - âœ” Improves site reliability: detects server failure, routes traffic to healthy servers.  
    - âœ” Enables cloud architectures:  
        - Cloud bursting (overflow traffic to cloud).  
        - Splitâ€‘application architectures (hybrid onâ€‘prem + cloud).  
    - âœ” Enforces security policies:  
        - WAF, authentication/authorization.  
        - Rate limiting.  
        - Deep packet inspection.  

-   How a Reverse Proxy Works (Technical Flow)

    A. Simple Forwarding (Passâ€‘through)
    - Accepts request.  
    - Forwards directly to backend.  
    - Minimal modification.  

    B. Full Proxy (Most Common)
    - Creates two separate TCP connections:  
        - Client â†’ Reverse Proxy.  
        - Reverse Proxy â†’ Backend Server.  
    - Connections are independent.  
    - Proxy can inspect, modify, compress, cache requests/responses.  

    Enables:
    - SSL offloading.  
    - Caching.  
    - Rate limiting.  
    - DDoS protection.  

-   How They Work Together in Modern Architecture
    Scenario: E-commerce website
        User â†’ DNS â†’ CDN (edge cache)
                â†“
            Reverse Proxy / WAF
                â†“
            Load Balancer
            â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
        App Server1  App Server2
            â”‚            â”‚
            â””â”€â†’ DB Servers


    Flow explanation:
    -   User requests homepage or static image.
    -   CDN serves cached content directly from nearest edge node â†’ fast response.
    -   If dynamic content or uncached file â†’ request goes to reverse proxy:
        -   Checks security, SSL, routes to backend server.
    -   Load balancer decides which backend server handles request.
        -   Uses round-robin, least-connections, or weighted routing.
    -   Backend server generates content â†’ proxy returns response â†’ client.
